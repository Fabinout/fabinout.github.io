---
layout: post
title: "[Video Game] Keyboard Warriors"
description: "Tentative de html et js embarquÃ© en jekyll"
category: 
tags: [test]
---

<body><canvas id="screen" width="1600" height="600" style="border:1px solid black"></canvas><p id="buffer">_</p><script> parcelRequire = (function (modules, cache, entry, globalName) { var previousRequire = typeof parcelRequire === 'function' && parcelRequire; var nodeRequire = typeof require === 'function' && require; function newRequire(name, jumped) { if (!cache[name]) { if (!modules[name]) { var currentRequire = typeof parcelRequire === 'function' && parcelRequire; if (!jumped && currentRequire) { return currentRequire(name, true); } if (previousRequire) { return previousRequire(name, true); } if (nodeRequire && typeof name === 'string') { return nodeRequire(name); } var err = new Error('Cannot find module \'' + name + '\''); err.code = 'MODULE_NOT_FOUND'; throw err; } localRequire.resolve = resolve; var module = cache[name] = new newRequire.Module(name); modules[name][0].call(module.exports, localRequire, module, module.exports, this); } return cache[name].exports; function localRequire(x){ return newRequire(localRequire.resolve(x)); } function resolve(x){ return modules[name][1][x] || x; } } function Module(moduleName) { this.id = moduleName; this.bundle = newRequire; this.exports = {}; } newRequire.isParcelRequire = true; newRequire.Module = Module; newRequire.modules = modules; newRequire.cache = cache; newRequire.parent = previousRequire; for (var i = 0; i < entry.length; i++) { newRequire(entry[i]); } if (entry.length) { var mainExports = newRequire(entry[entry.length - 1]); if (typeof exports === "object" && typeof module !== "undefined") { module.exports = mainExports; } else if (typeof define === "function" && define.amd) { define(function () { return mainExports; }); } else if (globalName) { this[globalName] = mainExports; } } return newRequire;})({4:[function(require,module,exports) { "use strict"; Object.defineProperty(exports, "__esModule", { value: true }); function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } var KeyboardListener = exports.KeyboardListener = function KeyboardListener(game) { _classCallCheck(this, KeyboardListener); window.onkeydown = function (ev) { var key = ev.key; if (key.length === 1 && key.toLowerCase() !== key.toUpperCase() || key === "-") { game.currentWord += ev.key; } else { if (key === "Backspace") { game.clearWord(); } } }; }; },{}],13:[function(require,module,exports) { "use strict"; Object.defineProperty(exports, "__esModule", { value: true }); var english_words = exports.english_words = ["drawer", "hose", "smoke", "apologise", "reminiscent", "spicy", "color", "replace", "boring", "steam", "enormous", "industrious", "fit", "healthy", "separate", "expect", "sleet", "crawl", "ground", "gaping", "thoughtless", "idiotic", "spiky", "wistful", "cabbage", "turn", "freezing", "natural", "heartbreaking", "unite", "delicious", "tree", "waiting", "cheerful", "shivering", "crown", "glib", "follow", "embarrass", "deafening", "like", "afford", "unique", "bushes", "guttural", "yak", "tire", "womanly", "adjustment", "daffy", "history", "event", "limit", "ossified", "library", "general", "steer", "correct", "exchange", "white", "acceptable", "sidewalk", "loving", "bath", "meat", "receptive", "rough", "believe", "weather", "guitar", "cheese", "bored", "slimy", "arrest", "punishment", "ring", "nutritious", "scratch", "rice", "slave", "work", "high-pitched", "faithful", "purring", "dog", "overrated", "overconfident", "obnoxious", "plants", "quack", "dead", "sponge", "pleasant", "encourage", "warm", "ordinary", "immense", "nut", "chunky", "festive"]; },{}],5:[function(require,module,exports) { "use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.random_word = exports.Word = undefined; var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); var _english_words = require("./english_words"); function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } var Word = exports.Word = function () { function Word(value, x, y) { _classCallCheck(this, Word); this.value = value; this.position = { x: x, y: y }; } _createClass(Word, [{ key: "draw", value: function draw(ctx, currentBuffer) { if (currentBuffer.length > 1 && this.value.startsWith(currentBuffer)) { ctx.font = "20px Arial"; ctx.fillStyle = "red"; ctx.fillText(currentBuffer, this.position.x, this.position.y); var x = ctx.measureText(currentBuffer).width; ctx.fillStyle = "black"; ctx.fillText(this.value.substring(currentBuffer.length), x + this.position.x, this.position.y); } else { ctx.font = "20px Arial"; ctx.fillStyle = "black"; ctx.fillText(this.value, this.position.x, this.position.y); } } }]); return Word; }(); var random_word = exports.random_word = function random_word() { return _english_words.english_words[Math.floor(Math.random() * _english_words.english_words.length)]; }; },{"./english_words":13}],14:[function(require,module,exports) { "use strict"; Object.defineProperty(exports, "__esModule", { value: true }); function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } var Unity = exports.Unity = function Unity(maxHealth, side) { _classCallCheck(this, Unity); this.health = { current: maxHealth, max: maxHealth }; this.side = side; }; },{}],6:[function(require,module,exports) { "use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.Soldier = undefined; var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); var _unity = require("./unity"); var _game = require("../game"); function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; } function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } var Soldier = exports.Soldier = function (_Unity) { _inherits(Soldier, _Unity); function Soldier(side) { _classCallCheck(this, Soldier); var _this = _possibleConstructorReturn(this, (Soldier.__proto__ || Object.getPrototypeOf(Soldier)).call(this, 50, side)); _this.position = 0; _this.size = 1; _this.speed = 2; _this.health = { current: 50, max: 50 }; _this.action = _game.ACTIONS.moving; _this.swordUp = true; _this.tick = 0; _this.swordAnimationLength = 32; _this.attackDamage = 3; return _this; } _createClass(Soldier, [{ key: "draw", value: function draw(context) { context.save(); context.translate(this.position + 140, 542); context.fillRect(0, 0, 20, 40); context.beginPath(); context.fillStyle = "bisque"; context.arc(10, -5, 8, 0, Math.PI * 2, true); context.fill(); context.beginPath(); context.lineWidth = 4; context.fillStyle = "black"; var swordStart = { x: 20, y: 10 }; context.translate(5, 0); var swordSize = { w: 10, h: 40 }; context.translate(swordStart.x, swordStart.y); if (this.swordUp) { context.rotate(45 * Math.PI / 180); context.fillRect(0, 0, 5, -40); context.fillRect(-7, -15, 20, 5); context.setTransform(1, 0, 0, 1, 0, 0); if (this.tick % this.swordAnimationLength === 0) { this.swordUp = false; } } else { context.rotate(90 * Math.PI / 180); context.fillRect(0, 0, 5, -40); context.fillRect(-7, -15, 20, 5); context.setTransform(1, 0, 0, 1, 0, 0); if (this.tick % this.swordAnimationLength === 0) { this.swordUp = true; } } context.restore(); } }, { key: "update", value: function update(game) { this.tick++; if (this.action === _game.ACTIONS.moving) { var foundEnemy = game.findEnemy(this); if (foundEnemy !== null) { this.target = foundEnemy; this.action = _game.ACTIONS.attacking; } else { this.position = Math.min(this.position + this.speed, 1330); } } else if (this.action === _game.ACTIONS.attacking) { if (this.tick % this.swordAnimationLength === 0) { this.target.health.current -= this.attackDamage; } } } }]); return Soldier; }(_unity.Unity); },{"./unity":14,"../game":2}],7:[function(require,module,exports) { "use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.SoldierSpell = undefined; var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); var _soldier = require("../unity/soldier"); function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } var SoldierSpell = exports.SoldierSpell = function () { function SoldierSpell() { _classCallCheck(this, SoldierSpell); this.name = "soldier"; this.cost = 30; this.casted = false; this.isBuff = false; } _createClass(SoldierSpell, [{ key: "cast", value: function cast(game) { console.log("soldier spell is casted"); game.add(new _soldier.Soldier()); } }]); return SoldierSpell; }(); },{"../unity/soldier":6}],8:[function(require,module,exports) { "use strict"; Object.defineProperty(exports, "__esModule", { value: true }); var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } var StrongerSpell = exports.StrongerSpell = function () { function StrongerSpell() { _classCallCheck(this, StrongerSpell); this.casted = false; this.name = "stronger"; this.cost = 40; this.isBuff = true; } _createClass(StrongerSpell, [{ key: "cast", value: function cast(game) { console.log("stronger spell is casted"); this.casted = true; } }, { key: "buff", value: function buff(unity) { unity.speed += 2; return unity; } }]); return StrongerSpell; }(); },{}],9:[function(require,module,exports) { "use strict"; Object.defineProperty(exports, "__esModule", { value: true }); var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } var FasterSpell = exports.FasterSpell = function () { function FasterSpell() { _classCallCheck(this, FasterSpell); this.casted = false; this.name = "faster"; this.cost = 20; this.isBuff = true; } _createClass(FasterSpell, [{ key: "cast", value: function cast(game) { console.log("faster spell is casted"); this.casted = true; } }, { key: "buff", value: function buff(unity) { unity.speed += 2; return unity; } }]); return FasterSpell; }(); },{}],2:[function(require,module,exports) { "use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.SIDE = exports.ACTIONS = undefined; var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); var _keyboardListener = require("./keyboardListener"); var _word2 = require("./word"); var _soldier = require("./unity/soldier"); var _soldierSpell = require("./spells/soldierSpell"); var _strongerSpell = require("./spells/strongerSpell"); var _fasterSpell = require("./spells/fasterSpell"); function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } var ACTIONS = exports.ACTIONS = { moving: Symbol("moving"), attacking: Symbol("attacking") }; var SIDE = exports.SIDE = { ally: Symbol("ally"), enemy: Symbol("enemy") }; var Game = function () { function Game() { _classCallCheck(this, Game); this.self = this; this.currentWord = ""; this.wordsToRecreate = []; var k = new _keyboardListener.KeyboardListener(this); this.size = { w: 1600, h: 600 }; this.availableWords = this.generateInitialWords(this.size); this.availableSpells = [new _soldierSpell.SoldierSpell(), new _strongerSpell.StrongerSpell(), new _fasterSpell.FasterSpell()]; this.allied = [new _soldier.Soldier(SIDE.ally)]; this.mana = 0; this.health = { max: 100, current: undefined }; this.health.current = this.health.max; this.world = { x0: 100, xs: this.size.w - 100 }; function generateSimpleOpponent() { return { health: { current: 100, max: 100 }, mana: 0 }; } this.opponent = generateSimpleOpponent(); this.ennemies = [this.opponent]; this.ticks = 0; var self = this; var tick = function tick() { self.ticks++; var ctx = document.getElementById("screen").getContext("2d"); self.update(); self.draw(ctx, self.size); requestAnimationFrame(tick); }; tick(); } _createClass(Game, [{ key: "generateInitialWords", value: function generateInitialWords(size) { var initialWords = []; for (var i = 0; i < 8; i++) { var colonne = i % 4; var rang = i < 4 ? 0 : 1; var x = size.w / 5 * colonne + 300; var y = size.h / 2 * rang + 80; initialWords.push(new _word2.Word((0, _word2.random_word)(), x, y)); } return initialWords; } }, { key: "update", value: function update() { var game = this; this.updateWords(); this.allied.forEach(function (b) { return b.update(game); }); } }, { key: "updateWords", value: function updateWords() { var _this = this; var aw = this.availableWords.map(function (w) { return w.value; }); var as = this.availableSpells.map(function (w) { return w.name; }); var contains = function contains(element) { return aw.indexOf(element) > -1; }; if (contains(this.currentWord)) { var word = aw.find(function (w) { return w === _this.currentWord; }); this.mana = Math.min(this.currentWord.length + this.mana, 100); var position = this.availableWords.find(function (w) { return w.value === _this.currentWord; }).position; this.wordsToRecreate.push({ x: position.x, y: position.y, time: this.ticks }); this.availableWords = this.availableWords.filter(function (w) { return w.value !== _this.currentWord; }); this.clearWord(); } else { if (as.indexOf(this.currentWord) > -1) { var spell = this.availableSpells.find(function (w) { return w.name === _this.currentWord; }); spell.cast(this); this.mana -= spell.cost; this.clearWord(); } } var self = this; var savedForLater = []; var _iteratorNormalCompletion = true; var _didIteratorError = false; var _iteratorError = undefined; try { for (var _iterator = this.wordsToRecreate[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) { var _word = _step.value; var cooldown = 100; if (self.ticks > _word.time + cooldown) { var value = (0, _word2.random_word)(); while (contains(value)) { value = (0, _word2.random_word)(); } this.availableWords.push(new _word2.Word(value, _word.x, _word.y)); } else { savedForLater.push(_word); } } } catch (err) { _didIteratorError = true; _iteratorError = err; } finally { try { if (!_iteratorNormalCompletion && _iterator.return) { _iterator.return(); } } finally { if (_didIteratorError) { throw _iteratorError; } } } this.wordsToRecreate = savedForLater; } }, { key: "findEnemy", value: function findEnemy(unity) { return null; } }, { key: "draw", value: function draw(ctx, canvasSize) { ctx.clearRect(0, 0, canvasSize.w, canvasSize.h); var _iteratorNormalCompletion2 = true; var _didIteratorError2 = false; var _iteratorError2 = undefined; try { for (var _iterator2 = this.availableWords[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) { var w = _step2.value; w.draw(ctx, this.currentWord); } } catch (err) { _didIteratorError2 = true; _iteratorError2 = err; } finally { try { if (!_iteratorNormalCompletion2 && _iterator2.return) { _iterator2.return(); } } finally { if (_didIteratorError2) { throw _iteratorError2; } } } this.drawManaBar(ctx, canvasSize, this.mana, this.availableSpells); this.drawMyHealthBar(ctx, canvasSize, this.health); this.drawOpponentHealthBar(ctx, canvasSize, this.opponent.health); this.drawBuffer(); this.allied.forEach(function (b) { return b.draw(ctx); }); } }, { key: "drawManaBar", value: function drawManaBar(ctx, canvasSize, mana, spells) { ctx.save(); ctx.lineWidth = "4"; var manaBarHeight = 500; var manaBarWidth = 50; ctx.translate(70, 580); ctx.rect(0, 0, manaBarWidth, -manaBarHeight); ctx.stroke(); ctx.lineWidth = "4"; ctx.fillStyle = "blue"; ctx.fillRect(0, 0, manaBarWidth, -manaBarHeight * mana / 100); ctx.font = "30px Courier New"; ctx.fillText("ðŸ’§", 15, -manaBarHeight - 40); ctx.font = "15px Courier New"; ctx.fillText(mana + "/100", 5, -manaBarHeight - 20); ctx.stroke(); var self = this; function drawSpells() { var cw = self.currentWord; ctx.fillStyle = "black"; ctx.font = "15px Courier New"; spells.forEach(function (w) { var y = 0 - 500 * w.cost / 100; var x = manaBarWidth + 10; if (w.casted) { ctx.fillStyle = "#D3D3D3"; ctx.fillText("- " + w.name, x, y); ctx.fillStyle = "black"; } else { if (cw.length > 0 && w.name.startsWith(cw)) { ctx.fillStyle = "red"; var firstText = "- " + cw; ctx.fillText(firstText, x, y); var wordWidth = ctx.measureText(firstText).width; ctx.fillStyle = "black"; ctx.fillText(w.name.substring(cw.length), wordWidth + x, y); } else { ctx.fillText("- " + w.name, x, y); } } ctx.stroke(); }); } drawSpells(); ctx.restore(); } }, { key: "drawMyHealthBar", value: function drawMyHealthBar(ctx, canvasSize, health) { ctx.save(); var maxHealth = health.max; ctx.lineWidth = "4"; var healthBarHeight = 500; var healthBarWidth = 50; ctx.translate(10, 580); ctx.rect(0, 0, healthBarWidth, -healthBarHeight); ctx.stroke(); ctx.lineWidth = "4"; ctx.fillStyle = "green"; ctx.fillRect(0, 0, healthBarWidth, -healthBarHeight * health.current / maxHealth); ctx.font = "35px Courier New"; ctx.fillText("ðŸ’•", 5, -healthBarHeight - 40); ctx.font = "15px Courier New"; ctx.fillText(health.current + "/" + maxHealth, 0 - 5, -healthBarHeight - 20); ctx.stroke(); ctx.restore(); } }, { key: "drawOpponentHealthBar", value: function drawOpponentHealthBar(ctx, canvasSize, health) { ctx.save(); var maxHealth = health.max; ctx.lineWidth = "4"; var healthBarHeight = 500; var healthBarWidth = 50; ctx.translate(canvasSize.w - 80, 580); ctx.rect(0, 0, healthBarWidth, -healthBarHeight); ctx.stroke(); ctx.lineWidth = "4"; ctx.fillStyle = "green"; ctx.fillRect(0, 0, healthBarWidth, -healthBarHeight * health.current / maxHealth); ctx.font = "35px Courier New"; ctx.fillText("ðŸ’•", 5, -healthBarHeight - 40); ctx.font = "15px Courier New"; ctx.fillText(health.current + "/" + maxHealth, 0 - 5, -healthBarHeight - 20); ctx.stroke(); ctx.restore(); } }, { key: "drawBuffer", value: function drawBuffer() { var p = document.getElementById("buffer"); p.innerHTML = this.currentWord; } }, { key: "clearWord", value: function clearWord() { this.currentWord = ""; } }, { key: "add", value: function add(unity) { var buffSpells = this.availableSpells.filter(function (s) { return s.isBuff && s.casted; }); var buffedUnity = unity; var _iteratorNormalCompletion3 = true; var _didIteratorError3 = false; var _iteratorError3 = undefined; try { for (var _iterator3 = buffSpells[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) { var spell = _step3.value; buffedUnity = spell.buff(buffedUnity); spell.casted = false; } } catch (err) { _didIteratorError3 = true; _iteratorError3 = err; } finally { try { if (!_iteratorNormalCompletion3 && _iterator3.return) { _iterator3.return(); } } finally { if (_didIteratorError3) { throw _iteratorError3; } } } this.allied.push(unity); } }]); return Game; }(); window.onload = new function () { new Game(); }(); },{"./keyboardListener":4,"./word":5,"./unity/soldier":6,"./spells/soldierSpell":7,"./spells/strongerSpell":8,"./spells/fasterSpell":9}],15:[function(require,module,exports) { var global = arguments[3]; var OVERLAY_ID = '__parcel__error__overlay__'; var OldModule = module.bundle.Module; function Module(moduleName) { OldModule.call(this, moduleName); this.hot = { data: module.bundle.hotData, _acceptCallbacks: [], _disposeCallbacks: [], accept: function (fn) { this._acceptCallbacks.push(fn || function () {}); }, dispose: function (fn) { this._disposeCallbacks.push(fn); } }; module.bundle.hotData = null; } module.bundle.Module = Module; var parent = module.bundle.parent; if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') { var hostname = '' || location.hostname; var protocol = location.protocol === 'https:' ? 'wss' : 'ws'; var ws = new WebSocket(protocol + '://' + hostname + ':' + '39543' + '/'); ws.onmessage = function (event) { var data = JSON.parse(event.data); if (data.type === 'update') { data.assets.forEach(function (asset) { hmrApply(global.parcelRequire, asset); }); data.assets.forEach(function (asset) { if (!asset.isNew) { hmrAccept(global.parcelRequire, asset.id); } }); console.clear(); } if (data.type === 'reload') { ws.close(); ws.onclose = function () { location.reload(); }; } if (data.type === 'error-resolved') { console.log('[parcel] âœ¨ Error resolved'); removeErrorOverlay(); } if (data.type === 'error') { console.error('[parcel] ðŸš¨ ' + data.error.message + '\n' + data.error.stack); removeErrorOverlay(); var overlay = createErrorOverlay(data); document.body.appendChild(overlay); } }; } function removeErrorOverlay() { var overlay = document.getElementById(OVERLAY_ID); if (overlay) { overlay.remove(); } } function createErrorOverlay(data) { var overlay = document.createElement('div'); overlay.id = OVERLAY_ID; var message = document.createElement('div'); var stackTrace = document.createElement('pre'); message.innerText = data.error.message; stackTrace.innerText = data.error.stack; overlay.innerHTML = '<div style="background: black; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; opacity: 0.85; font-family: Menlo, Consolas, monospace; z-index: 9999;">' + '<span style="background: red; padding: 2px 4px; border-radius: 2px;">ERROR</span>' + '<span style="top: 2px; margin-left: 5px; position: relative;">ðŸš¨</span>' + '<div style="font-size: 18px; font-weight: bold; margin-top: 20px;">' + message.innerHTML + '</div>' + '<pre>' + stackTrace.innerHTML + '</pre>' + '</div>'; return overlay; } function getParents(bundle, id) { var modules = bundle.modules; if (!modules) { return []; } var parents = []; var k, d, dep; for (k in modules) { for (d in modules[k][1]) { dep = modules[k][1][d]; if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) { parents.push(+k); } } } if (bundle.parent) { parents = parents.concat(getParents(bundle.parent, id)); } return parents; } function hmrApply(bundle, asset) { var modules = bundle.modules; if (!modules) { return; } if (modules[asset.id] || !bundle.parent) { var fn = new Function('require', 'module', 'exports', asset.generated.js); asset.isNew = !modules[asset.id]; modules[asset.id] = [fn, asset.deps]; } else if (bundle.parent) { hmrApply(bundle.parent, asset); } } function hmrAccept(bundle, id) { var modules = bundle.modules; if (!modules) { return; } if (!modules[id] && bundle.parent) { return hmrAccept(bundle.parent, id); } var cached = bundle.cache[id]; bundle.hotData = {}; if (cached) { cached.hot.data = bundle.hotData; } if (cached && cached.hot && cached.hot._disposeCallbacks.length) { cached.hot._disposeCallbacks.forEach(function (cb) { cb(bundle.hotData); }); } delete bundle.cache[id]; bundle(id); cached = bundle.cache[id]; if (cached && cached.hot && cached.hot._acceptCallbacks.length) { cached.hot._acceptCallbacks.forEach(function (cb) { cb(); }); return true; } return getParents(global.parcelRequire, id).some(function (id) { return hmrAccept(global.parcelRequire, id); }); } },{}]},{},[15,2], null)</script></body>